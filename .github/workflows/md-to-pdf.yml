name: Obsidian-style Markdown -> PDF

on:
  push:
    branches:
      - main
    paths:
      - '**/*.md'

permissions:
  contents: write

jobs:
  md-to-pdf:
    runs-on: ubuntu-latest
    env:
      REPO: ${{ github.repository }}
      GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Determine changed markdown files (exclude README.md)
        id: changed
        run: |
          set -euo pipefail
          BEFORE="${{ github.event.before }}"
          AFTER="${{ github.sha }}"

          if [ "$BEFORE" = "0000000000000000000000000000000000000000" ]; then
            git ls-files '*.md' > all_md.txt || true
          else
            git diff --name-only "$BEFORE" "$AFTER" -- '*.md' > all_md.txt || true
          fi

          # Exclude README.md (case-insensitive)
          grep -v -Ei '(^|/)(readme)\.md$' all_md.txt > changed_md_filtered.txt || true

          echo "files<<EOF" >> "$GITHUB_OUTPUT"
          if [ -s changed_md_filtered.txt ]; then
            cat changed_md_filtered.txt >> "$GITHUB_OUTPUT"
          fi
          echo "EOF" >> "$GITHUB_OUTPUT"

      - name: Install system deps (Chromium/Electron prerequisites)
        if: ${{ steps.changed.outputs.files != '' }}
        run: |
          set -euo pipefail
          sudo apt-get update -y
          sudo apt-get install -y --no-install-recommends \
            xvfb \
            libgtk-3-0 \
            libxss1 \
            libnss3 \
            libx11-xcb1 \
            libxcomposite1 \
            libxdamage1 \
            libxrandr2 \
            libgbm1 \
            fonts-liberation \
            ca-certificates


      - name: Setup Node.js
        if: ${{ steps.changed.outputs.files != '' }}
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install Node packages (electron + renderer libs)
        if: ${{ steps.changed.outputs.files != '' }}
        run: |
          set -euo pipefail
          npm init -y
          npm install electron@latest markdown-it markdown-it-footnote markdown-it-deflist markdown-it-abbr markdown-it-attrs highlight.js

      - name: Convert changed markdown to PDF using Electron
        if: ${{ steps.changed.outputs.files != '' }}
        env:
          FILES: ${{ steps.changed.outputs.files }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          REPO: ${{ github.repository }}
        run: |
          set -euo pipefail
          # create the electron script
          cat > electron-print.js <<'NODE'
          const fs = require('fs');
          const path = require('path');
          const { execSync } = require('child_process');
          const { app, BrowserWindow } = require('electron');
          const md = require('markdown-it')({
            html: true,
            linkify: true,
            typographer: true
          }).use(require('markdown-it-footnote'))
            .use(require('markdown-it-deflist'))
            .use(require('markdown-it-abbr'))
            .use(require('markdown-it-attrs'));
          const hljs = require('highlight.js');

          // highlight code blocks
          md.set({
            highlight: function (str, lang) {
              try {
                if (lang && hljs.getLanguage(lang)) {
                  return '<pre class="hljs"><code>' +
                         hljs.highlight(str, { language: lang, ignoreIllegals: true }).value +
                         '</code></pre>';
                }
              } catch (e) {}
              return '<pre class="hljs"><code>' + md.utils.escapeHtml(str) + '</code></pre>';
            }
          });

          const filesEnv = process.env.FILES || '';
          const repo = process.env.REPO || '';
          const token = process.env.GITHUB_TOKEN || '';

          const files = filesEnv.split(/\r?\n/).map(s => s.trim()).filter(Boolean);

          // load optional Obsidian CSS if present
          let themeCss = '';
          const themePath = path.join(process.cwd(), '.obsidian', 'export.css');
          if (fs.existsSync(themePath)) {
            themeCss = fs.readFileSync(themePath, 'utf8');
            console.log('Using .obsidian/export.css for styling');
          } else {
            // fallback minimal CSS + highlight.js default style
            themeCss = `
            /* Minimal page styling */
            body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial; padding: 28px; color: #222; background: #fff; }
            .markdown-body { max-width: 980px; margin: 0 auto; }
            pre { background: #f6f8fa; padding: 12px; border-radius: 6px; overflow: auto; }
            code { font-family: "SFMono-Regular", Menlo, Monaco, "Roboto Mono", "Courier New", monospace; }
            /* include highlight.js default */
            ${require('highlight.js').getStyleSheet ? require('highlight.js').getStyleSheet() : ''}
            `;
          }

          // create a data URL wrapper for HTML
          function buildHtml(title, content) {
            return `<!doctype html>
            <html>
              <head>
                <meta charset="utf-8">
                <meta name="viewport" content="width=device-width,initial-scale=1">
                <title>${title}</title>
                <style>
                  ${themeCss}
                </style>
              </head>
              <body>
                <article class="markdown-body">
                  ${content}
                </article>
              </body>
            </html>`;
          }

          // Electron app lifecycle
          app.whenReady().then(async () => {
            // create a hidden BrowserWindow for printing
            const win = new BrowserWindow({
              width: 1200,
              height: 1600,
              show: false,
              webPreferences: {
                sandbox: false,
                nodeIntegration: false,
                contextIsolation: true
              }
            });

            let anyStaged = false;

            for (const mdPath of files) {
              try {
                console.log('Processing', mdPath);
                const markdown = fs.readFileSync(mdPath, 'utf8');
                const htmlBody = md.render(markdown);
                const html = buildHtml(path.basename(mdPath), htmlBody);

                // load content
                await win.loadURL('data:text/html;charset=utf-8,' + encodeURIComponent(html));
                // wait for networkidle-like (small delay)
                await new Promise(r => setTimeout(r, 250));

                // print to PDF with A4 portrait
                const pdfPath = mdPath.replace(/\.md$/i, '.pdf');
                const pdfData = await win.webContents.printToPDF({
                  printBackground: true,
                  landscape: false,
                  pageSize: 'A4',
                  marginsType: 1
                });

                fs.writeFileSync(pdfPath, pdfData);
                console.log('Wrote PDF:', pdfPath);

                // compare with HEAD version
                let needsAdd = false;
                try {
                  const tmpOld = path.join('/tmp', 'old_' + path.basename(pdfPath));
                  try {
                    execSync(`git show HEAD:"${pdfPath}" > "${tmpOld}" 2>/dev/null || true`);
                  } catch (e) {}
                  if (!fs.existsSync(tmpOld)) {
                    needsAdd = true;
                  } else {
                    const oldBuf = fs.readFileSync(tmpOld);
                    const newBuf = fs.readFileSync(pdfPath);
                    if (!oldBuf.equals(newBuf)) needsAdd = true;
                    fs.unlinkSync(tmpOld);
                  }
                } catch (e) {
                  needsAdd = true;
                }

                if (needsAdd) {
                  execSync(`git add "${pdfPath}"`);
                  anyStaged = true;
                  console.log('Staged', pdfPath);
                } else {
                  console.log('No change for', pdfPath);
                }

              } catch (err) {
                console.error('Error processing', mdPath, err && err.stack ? err.stack : err);
                // continue to next file
              }
            }

            if (anyStaged) {
              try {
                execSync('git commit -m "chore: update PDFs generated from changed markdown files" || true', { stdio: 'inherit' });
                execSync('git push origin HEAD:main', { stdio: 'inherit' });
                console.log('Committed and pushed updated PDFs');
              } catch (err) {
                console.error('Commit/push failed', err && err.message ? err.message : err);
                process.exit(1);
              }
            } else {
              console.log('No PDF changes to commit');
            }

            app.quit();
          }).catch(err => {
            console.error(err);
            app.quit();
            process.exit(1);
          });
          NODE

          # run the electron script under xvfb (Electron needs an X server on ubuntu runners)
          # install electron (if not already installed)
          npm install electron@latest --no-audit --no-fund
          
          # run the script with the electron binary under Xvfb
          xvfb-run --auto-servernum --server-args='-screen 0 1280x1024x24' npx electron electron-print.js

      - name: No changed markdown files
        if: ${{ steps.changed.outputs.files == '' }}
        run: echo "No changed markdown files to process (or only README.md changed)"
